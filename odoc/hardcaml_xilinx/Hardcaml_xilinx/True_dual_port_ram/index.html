<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>True_dual_port_ram (hardcaml_xilinx.Hardcaml_xilinx.True_dual_port_ram)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">hardcaml_xilinx</a> &#x00BB; <a href="../index.html">Hardcaml_xilinx</a> &#x00BB; True_dual_port_ram</nav><header class="odoc-preamble"><h1>Module <code><span>Hardcaml_xilinx.True_dual_port_ram</span></code></h1><p>True Dual Port Memory with independent clocks for ports <code>a</code> and <code>b</code>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?read_latency:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span>
  <span>?arch:<a href="../Ram_arch/index.html#type-t">Ram_arch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?byte_write_width:<a href="../Byte_write_width/index.html#type-t">Byte_write_width.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?memory_optimization:<span class="xref-unresolved">Base</span>.bool <span class="arrow">&#45;&gt;</span></span>
  <span>?cascade_height:<a href="../Cascade_height/index.html#type-t">Cascade_height.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?simulation_name:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>build_mode:<a href="../../../hardcaml/Hardcaml/Build_mode/index.html#type-t">Hardcaml.Build_mode.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.unit <span class="arrow">&#45;&gt;</span></span>
  <span>clock_a:<a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>clock_b:<a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>clear_a:<a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>clear_b:<a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>size:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span>
  <span>port_a:<span><a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <a href="../Ram_port/index.html#type-t">Ram_port.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>port_b:<span><a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <a href="../Ram_port/index.html#type-t">Ram_port.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> * <a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a></span></code></div><div class="spec-doc"><p>Create a Xilinx compatible memory. For <code>Synthesis</code> the XPM memory generator is used by generating a <code>xpm_memory_tdpram</code> instantiation with appropriate parameters. For <code>Simulation</code> hardcaml multiport memories are used to model the Xilinx memory behaviour.</p><p>The interface to the RAM differs subtly from the core primitives - we use seperate read and write enables, rather than a single enable and write signal. The mapping is as follows:</p><ul><li>write_enable = enable &amp; write</li><li>read_enable = enable</li></ul><p>The main difference occurs when write_enable and read_enable are both high. In the <code>No_change</code> collision mode, the read will not occur.</p><p>The documentation explains what happens across ports on address collisions, and in some cases this leads to <code>X</code>s on the output of one port of the other. Hardcaml cannot model this behaviour, so it is up to the designer to be 'very careful' in these cases. Please see the table at the top of the implementation file for more information.</p><p>Ultraram has it's own subtle behaviour on address collision and this is modelled in hardcaml by putting the ports in opposite read/write first modes.</p><p>Distributed RAM is set up to work the same as BlockRAM.</p><p>There is a verilog testbench in <code>test_hdl</code> which works with the <code>xsim_modelling</code> application to test the subtle address collision cases.</p></div></div></div></body></html>