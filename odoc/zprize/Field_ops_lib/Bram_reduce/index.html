<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bram_reduce (zprize.Field_ops_lib.Bram_reduce)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">zprize</a> &#x00BB; <a href="../index.html">Field_ops_lib</a> &#x00BB; Bram_reduce</nav><header class="odoc-preamble"><h1>Module <code><span>Field_ops_lib.Bram_reduce</span></code></h1><p>Module to reduce numbers modulo a fixed constant with just two subtraction stages.</p> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script> <p>Given a fixed modular base \(p\) with \(n\) bits and a multiplicative error \(E\) with \(e\) bits, this module can reduce any input \(N\in[0, Ep)\) to an equivalent value modulo \(p\) in the range \([0, p)\) with just two subtraction stages.</p><p>The module accomplishes this by precomputing and loading a ROM with \(2^e\) entries. We set \(R[0] = 0\). Then, for \(i\geq1\), entry \(R[i]\) holds the final \(n\) bits of the largest multiple of \(p\) that has \(i-1\) as its \(e\)-bit prefix when written with \(e+n\) bits. In particular,</p> $$R[i] = \left\lfloor \frac{(i-1)\cdot 2^n}{p} \right\rfloor\pmod {2^{n}} $$ <p>Then, given an input \(N\in[0,Ep)\) with \(e+n\) bits, we can lookup its \(e\)-bit prefix in the ROM and subtract the resulting value from the \(n\)-bit suffix of our input value:</p> $$ N[n-1:0] - R\left[N[e-1+n:n]\right] $$ <p>(note that we only need to use the lower \(n\) bits because we know what the higher bits are by construction). Then, when the lookup index is nonzero, we have to invert the MSB of the signed result to get an unsigned reduction \(n^\prime\) to the range \([0,3p)\).</p><p>After this, we do one more subtraction stage where we just multiplex between \(\{n^\prime, n^\prime-p, n^\prime-2p\}\) to choose the final result.</p><p>This module can be generalized over any modular base \(p\) (not necessarily prime), rather than just our given prime. However, this requires a bit of care to double check the bounds above - in our case, the first ROM reduction goes to the range \([0,3p)\), but for some bases, it is possible that the reduction only goes to \([0,4p)\) and requires one more subtractor in the subsequent stage.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module-type" id="module-type-Config" class="anchored"><a href="#module-type-Config" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Config/index.html">Config</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Config/index.html">Config</a> : <a href="module-type-Config/index.html">Config</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>