<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mixed_add_precompute (zprize.Twisted_edwards_lib.Mixed_add_precompute)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">zprize</a> &#x00BB; <a href="../index.html">Twisted_edwards_lib</a> &#x00BB; Mixed_add_precompute</nav><header class="odoc-preamble"><h1>Module <code><span>Twisted_edwards_lib.Mixed_add_precompute</span></code></h1><p>Fully/Half pipelined mixed addition for a scaled <a href="https://en.wikipedia.org/wiki/Twisted_Edwards_curve">twisted edwards curve</a> curve (ie: <code>a = -1</code>), optimized with precomputation.</p><p>This implementation is designed such that one of the points is a running sum computed on the FPGA, and the other point is a relatively static affine point streamed from the host.</p><p>This is useful when the affine points are added into the running sum for many many times before needing to convert back to the original coordinate system.</p></header><nav class="odoc-toc"><ul><li><a href="#precomputation-optimization">Precomputation Optimization</a></li><li><a href="#implementation-details">Implementation Details</a></li></ul></nav><div class="odoc-content"><h2 id="precomputation-optimization"><a href="#precomputation-optimization" class="anchor"></a>Precomputation Optimization</h2><p>The key idea is to transform the two points (one in extended coordinate system, and another in affine coordinates) we want to add into an entirely different coordinate system such that we can skip some computation.</p><p>The running sum in the FPGA, which is usually represented in <a href="https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html">extended coordinate system</a>, is represented as follows</p><pre><code>running_sum_representaiton(x, y, z, t) = ( 2(y-x), 2(y+x), 4z, t )</code></pre><p>Transforming the <code>running_sum</code> back to extended coordinate system is simply the following:</p><pre><code>running_sum_to_extended(p, q, r, s) = ( (p-q)/4, (p+q)/4, r/4, s )</code></pre><p>Note that this means that the identity element in this coordinate system is no longer just <code>(0, 1, 1, 0)</code>, but rather <code>(2, 2, 4, 0)</code>. Also note that <code>x/z * y/z != t/z</code> in the new coordinate system.</p><p>The relative static point has a completely different representation:</p><pre><code>relatively_static_point_representation(x,y,t) =( (y-x)/2, (y+x)/2, 4*d*t )</code></pre><p>Simliar to the running sum's internal representation, <code>x * y != t</code> in the new coordinate system. Unlike running sum, we will never convert this back to the projective coordinates. It's main purpose to be converted into this coordinate system is to be added into the running sum efficiently.</p><p>Addition between these two newly defined coordinate system is as follows:</p><pre><code>let add_unified_with_precompute running_sum static_point =
  (* [x], [y], [z] and [t] is in the running sum representation
     coordinate system.
  *)
  let { x; y; t; z } = running_sum in
  (* [x_host], [y_host] and [t_host] is in the static point
     representation cooridnate system.
  *)
  let { x_host; y_host; t_host } = static_point in
  let c_A    = x1 * x_host in
  let c_B    = y1 * y_host in
  let c_C    = t1 * t_host in
  let c_D    = z1 in
  let c_E    = c_B - c_A in
  let c_F    = c_D - c_C in
  let c_G    = c_D + c_C in
  let c_H    = c_B + c_A in
  let pre_x3 = c_E * c_F in
  let pre_y3 = c_G * c_H in
  let t3     = c_E * c_H in
  let z3     = c_F * c_G in
  let x3     = pre_y3 - pre_x3 in
  let y3     = pre_y3 + pre_x3 in
  { x = x3; y = y3; z = z3; t = t3 }
;;</code></pre><p>The exact proof of that this is equivalent to the <a href="https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3">vanilla mixed addition formulae</a> after the transformations is beyond the scope of this document, as it is too large to fit in the margin of our screen.</p><p>This mixed adder uses 1 less resources than the vanilla addition formulae. as requires 7M and 6A (over <code>7M + 8A + 1*2 + 1*k</code>) at the cost of some preprocessing and post-processing.</p><h2 id="implementation-details"><a href="#implementation-details" class="anchor"></a>Implementation Details</h2><p>Our implementation supports a fully-pipelined multiplier (one that can accept input every cycle) or a half-pipelined one (one that can accept input every two cycles). The latter is less resource efficient, as it uses 4 multipliers.</p><p>The configuration of the adder can be specified via the <a href="../Config/index.html#type-t"><code>Config.t</code></a> type. Most notably, thie module instantiates every stage as a hierarchical module. The <code>slr_assignments</code> field in the config allows the user to specify which SLR every stage should be mapped to. Under the hood, this does two things:</p><ul><li>inserts a SLR{0,1,2} suffix to the instantiation name, in which the user can use for pblocking in placement)</li><li>automatically insert registers between stages which are not in the same SLR. These registers are hierachically created with SLR{0,1,2} suffix in their instantiation name so they can be pblocked.</li></ul><div class="odoc-include"><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Num_bits/index.html">Num_bits</a> : <a href="../Num_bits/module-type-S/index.html">Num_bits.S</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></div></body></html>