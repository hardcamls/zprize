<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Signal_graph (hardcaml.Hardcaml.Signal_graph)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">hardcaml</a> &#x00BB; <a href="../index.html">Hardcaml</a> &#x00BB; Signal_graph</nav><header class="odoc-preamble"><h1>Module <code><span>Hardcaml.Signal_graph</span></code></h1><p>A <code>Signal_graph.t</code> is a created from a list of signals, and defined by tracing back to inputs (unassigned wires or constants). Functions are provided for traversing the graph.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a <code>Signal_graph.t</code> from a list of signals (commonly, circuit outputs).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inputs" class="anchored"><a href="#val-inputs" class="anchor"></a><code><span><span class="keyword">val</span> inputs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> <span class="xref-unresolved">Base</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p>Traverse the graph and find all inputs. Badly formed inputs (no name, or multiple names) return an error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-outputs" class="anchored"><a href="#val-outputs" class="anchor"></a><code><span><span class="keyword">val</span> outputs : <span>?validate:<span class="xref-unresolved">Base</span>.bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> <span class="xref-unresolved">Base</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p>Return the outputs of the signal graph. If <code>validate</code> is <code>true</code>, then the outputs are checked for compatibility with circuit outputs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-depth_first_search" class="anchored"><a href="#val-depth_first_search" class="anchor"></a><code><span><span class="keyword">val</span> depth_first_search : 
  <span>?deps:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?f_before:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?f_after:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Visit all signals in the graph, starting at the outputs, in a depth-first manner. Each signal is visited only once. <code>f_before</code> is called before recursing on each signal's fan-in. Similiarly, <code>f_after</code> is called after recursing on the fan-in.</p><p>If <code>deps</code> is provided it will be used to compute signal dependencies rather than the default definition. This is useful for terminating traversals based on some condition on signals, e.g., if it's a register or a memory.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold across all signals in the graph, starting at the outputs. Each signal is visited only once.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Return a list of all signals in the graph for whom <code>f signal</code> returns true.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit )</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Iterate over all signals in the graph.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-detect_combinational_loops" class="anchored"><a href="#val-detect_combinational_loops" class="anchor"></a><code><span><span class="keyword">val</span> detect_combinational_loops : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.unit <span class="xref-unresolved">Base</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p>Retuns an error if the graph has a combinational loop, that is, a path from a signal back to itself that doesn't pass though a register, memory or instantiation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-normalize_uids" class="anchored"><a href="#val-normalize_uids" class="anchor"></a><code><span><span class="keyword">val</span> normalize_uids : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>normalize_uids t</code> creates a copy of <code>t</code> that is identical to <code>t</code> except the uids are numbered starting at 1.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fan_out_map" class="anchored"><a href="#val-fan_out_map" class="anchor"></a><code><span><span class="keyword">val</span> fan_out_map : 
  <span>?deps:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Signal/Uid_set/index.html#type-t">Signal.Uid_set.t</a> <span class="xref-unresolved">Base</span>.Map.M(<span class="xref-unresolved">Hardcaml__</span>.Signal.Uid).t</span></span></code></div><div class="spec-doc"><p>Fan-out of each signal in the signal graph. The fan-out of a signal is the set of signals it drives.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fan_in_map" class="anchored"><a href="#val-fan_in_map" class="anchor"></a><code><span><span class="keyword">val</span> fan_in_map : 
  <span>?deps:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Signal/Uid_set/index.html#type-t">Signal.Uid_set.t</a> <span class="xref-unresolved">Base</span>.Map.M(<span class="xref-unresolved">Hardcaml__</span>.Signal.Uid).t</span></span></code></div><div class="spec-doc"><p>Fan-in of each signal in the signal graph. The fan-in of a signal is the set of signals that drive it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-topological_sort" class="anchored"><a href="#val-topological_sort" class="anchor"></a><code><span><span class="keyword">val</span> topological_sort : 
  <span>?deps:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p><code>topological_sort t</code> sorts the signals in <code>t</code> so that all the signals in <code>deps s</code> occur before <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scheduling_deps" class="anchored"><a href="#val-scheduling_deps" class="anchor"></a><code><span><span class="keyword">val</span> scheduling_deps : <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Signal dependencies used for scheduling. Breaks loops through sequential elements like registers and memories.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last_layer_of_nodes" class="anchored"><a href="#val-last_layer_of_nodes" class="anchor"></a><code><span><span class="keyword">val</span> last_layer_of_nodes : 
  <span>is_input:<span>( <span><a href="../Signal/index.html#type-t">Signal.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Signal/Uid/index.html#type-t">Signal.Uid.t</a> <span class="xref-unresolved">Base</span>.List.t</span></span></code></div><div class="spec-doc"><p>Final layer of combinational nodes which sit on the path between the outputs and any driving register or memory.</p></div></div></div></body></html>