<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Memory_builder (hardcaml_xilinx.Hardcaml_xilinx.Memory_builder)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">hardcaml_xilinx</a> &#x00BB; <a href="../index.html">Hardcaml_xilinx</a> &#x00BB; Memory_builder</nav><header class="odoc-preamble"><h1>Module <code><span>Hardcaml_xilinx.Memory_builder</span></code></h1><p>A general-purpose means of representing memories. The <code>Config.t</code> type allows the user to configure the underlying memory implementations. Eg: Using URAM for bits 0-72, and BRAMs for bits 73-80. This module allows construction of memories in 1D or 2D Modes. See further documentation below.</p></header><nav class="odoc-toc"><ul><li><a href="#straightforward-1d-memories">Straightforward 1D Memories</a></li><li><a href="#general-purpose-&quot;2d&quot;-memories">General-Purpose &quot;2D&quot; Memories</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-For_deriving" class="anchored"><a href="#module-For_deriving" class="anchor"></a><code><span><span class="keyword">module</span> <a href="For_deriving/index.html">For_deriving</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Config" class="anchored"><a href="#module-Config" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Config/index.html">Config</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Configuration for the memory builder. See documentation below for elaboration about the purpose of configuration fields.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Port_label" class="anchored"><a href="#module-Port_label" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Port_label/index.html">Port_label</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Create" class="anchored"><a href="#module-Create" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Create/index.html">Create</a></span><span> (<a href="Create/argument-1-M/index.html">M</a> : <a href="../../../hardcaml/Hardcaml/Interface/module-type-S/index.html">Hardcaml.Interface.S</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_latency" class="anchored"><a href="#val-read_latency" class="anchor"></a><code><span><span class="keyword">val</span> read_latency : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div><div class="spec-doc"><p>Returns the read latency of the memory, including possibly any combinational latency due to muxing.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-complete" class="anchored"><a href="#val-complete" class="anchor"></a><code><span><span class="keyword">val</span> complete : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Must be called strictly after all <code>set_{read/write}_</code> functions have been called. This assigns to the underlying instantiated memories, and asserts that the memory satisfies the config's requirements.</p></div></div><h3 id="straightforward-1d-memories"><a href="#straightforward-1d-memories" class="anchor"></a>Straightforward 1D Memories</h3><p>1-dimensional memories are laid out the way one would expect. A memory of depth <code>d</code>, with columns shared between URAM and BRAM will have the following layout:</p><p>| URAM | BRAM | | x<code>0</code> | | x<code>1</code> | | .... | | x<code>d-1</code> | ------------------------</p><p><code>Read_port_1d</code> does not implement Hardcaml.Interface.S, since the <code>address</code> and <code>data</code> are not necessarily known without a config. To get something one can use in Hardcaml interfaces, you'll have to specialize it with <code>Specialize</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-Widths_1d" class="anchored"><a href="#module-type-Widths_1d" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Widths_1d/index.html">Widths_1d</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Read_port_1d" class="anchored"><a href="#module-Read_port_1d" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Read_port_1d/index.html">Read_port_1d</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>General purpose 1D read ports.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Write_port_1d" class="anchored"><a href="#module-Write_port_1d" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Write_port_1d/index.html">Write_port_1d</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>General purpose 1D Write ports. Note that it is possible to write <code>'a Write_port_1d.M(Foo).t</code> in type declarations in mlis.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_read_port_1d" class="anchored"><a href="#val-set_read_port_1d" class="anchor"></a><code><span><span class="keyword">val</span> set_read_port_1d : 
  <span><span><span class="type-var">'data</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Port_label/index.html#type-t">Port_label.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <a href="Read_port_1d/index.html#type-t">Read_port_1d.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'data</span></span></code></div><div class="spec-doc"><p>Assigns the read port for 1D memories. Raises a runtime exception when called on a non single dimensional memory.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_write_port_1d" class="anchored"><a href="#val-set_write_port_1d" class="anchor"></a><code><span><span class="keyword">val</span> set_write_port_1d : 
  <span><span><span class="type-var">'data</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Port_label/index.html#type-t">Port_label.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a>, <span class="type-var">'data</span> )</span> <a href="Write_port_1d/index.html#type-t">Write_port_1d.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Similar to <code>set_read_port_1d</code>, but for write ports.</p></div></div><h3 id="general-purpose-&quot;2d&quot;-memories"><a href="#general-purpose-&quot;2d&quot;-memories" class="anchor"></a>General-Purpose &quot;2D&quot; Memories</h3><p>The more general-purporse memory builders can be used to construct memories with the layout <code>H * V</code> where every entry is <code>B</code> bits wide. One can read from any of the entires through the read ports. When writing, however, an entire horizontal index must be written to at once, namely x<code>*, v</code>. This is because the memory is represented using parallel columns of memories along the H axis.</p><p>Under the hood, this constructs a memory of depth <code>V</code> and width <code>H * B</code> using the <code>underlying_memories</code> constructs provided by the <code>Config.t</code>. When reading (h, v), the memory reads the underlying memory at index <code>v</code>, which returns <code>H</code> copies of the the data, and multiplexes them with <code>h</code>. For that reason, <code>V</code> must be a power of two, but <code>H</code> does not have to be.</p><p>Here's a possible underlying layout by using this memory builder, for H=3, V=8, implemented with 2 URAMs and 1 BRAMs.</p><p>| URAM | BRAM | BRAM | | x<code>0</code><code>0</code> | x<code>1</code><code>0</code> | x<code>2</code><code>0</code> | | x<code>0</code><code>1</code> | x<code>1</code><code>1</code> | x<code>2</code><code>1</code> | | x<code>0</code><code>2</code> | x<code>1</code><code>2</code> | x<code>2</code><code>2</code> | | x<code>0</code><code>3</code> | x<code>1</code><code>3</code> | x<code>2</code><code>3</code> | | x<code>0</code><code>4</code> | x<code>1</code><code>4</code> | x<code>2</code><code>4</code> | | x<code>0</code><code>5</code> | x<code>1</code><code>5</code> | x<code>2</code><code>5</code> | | x<code>0</code><code>6</code> | x<code>1</code><code>6</code> | x<code>2</code><code>6</code> | | x<code>0</code><code>7</code> | x<code>1</code><code>7</code> | x<code>2</code><code>7</code> | --------------------------------------</p><p>Since writes to a row are atomic, for a given <code>v</code> and <code>d</code>, all entries at x<code>{0, 1, 2}</code><code>d</code> must be written to simultaneously.</p><p>Note that 1D memories are simply a special case of 2D memories where H = 1.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-Widths_2d" class="anchored"><a href="#module-type-Widths_2d" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Widths_2d/index.html">Widths_2d</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Read_port_2d" class="anchored"><a href="#module-Read_port_2d" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Read_port_2d/index.html">Read_port_2d</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>General-purpose Read Ports.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Write_port_2d" class="anchored"><a href="#module-Write_port_2d" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Write_port_2d/index.html">Write_port_2d</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>General purpose write ports. Note that it is possible to write <code>'a Write_port_2d.M(Foo).t in type declarations in mlis
</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_write_port_2d" class="anchored"><a href="#val-set_write_port_2d" class="anchor"></a><code><span><span class="keyword">val</span> set_write_port_2d : 
  <span><span><span class="type-var">'data</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Port_label/index.html#type-t">Port_label.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a>, <span class="type-var">'data</span> )</span> <a href="Write_port_2d/index.html#type-t">Write_port_2d.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Set the write port.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_read_port_2d" class="anchored"><a href="#val-set_read_port_2d" class="anchor"></a><code><span><span class="keyword">val</span> set_read_port_2d : 
  <span><span><span class="type-var">'data</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Port_label/index.html#type-t">Port_label.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../hardcaml/Hardcaml/Signal/index.html#type-t">Hardcaml.Signal.t</a> <a href="Read_port_2d/index.html#type-t">Read_port_2d.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'data</span></span></code></div><div class="spec-doc"><p>Set the read port. This should only ever be called once.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-M" class="anchored"><a href="#module-M" class="anchor"></a><code><span><span class="keyword">module</span> <a href="M/index.html">M</a></span><span> (<a href="M/index.html#argument-1-X">X</a> : <span class="xref-unresolved">Base</span>.T1) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Shorthand useful for writing Memory_builder.M(Foo).t</p></div></div></div></body></html>