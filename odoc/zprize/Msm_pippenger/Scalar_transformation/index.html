<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Scalar_transformation (zprize.Msm_pippenger.Scalar_transformation)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">zprize</a> &#x00BB; <a href="../index.html">Msm_pippenger</a> &#x00BB; Scalar_transformation</nav><header class="odoc-preamble"><h1>Module <code><span>Msm_pippenger.Scalar_transformation</span></code></h1><p>Module to transform scalars to a signed-digit representation, which is expected by the downstream FPGA logic.</p> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script> <p>The main transform currently implemented transforms the input scalar from unsigned digits in the range  \([0,2^b-1]\)  to signed digits in the range  \([-2^{b-1}, 2^{b-1}-1]\) .</p><p>It does this as follows: suppose we have a B-bit scalar  \(k\), split into  \(N\)  windows of size  \(b_i\) , where  \(\sum_{i=0}^{N-1}{b_i} = B\) . Then, letting  \(o_i = \sum_{j=0}^{i-1}{b_i}\)  be the offsets of each digit, we can write  $$ k = \sum_{i=0}^{N-1}{2^{o_i}d_i},\;\; d_i\in[0,2^b_i-1]\;\forall i  $$  as a normal unsigned representation of  \(k\)  (derived by just directly windowing the bits in its binary representation).</p><p>Then, we perform the following iterative transform from  \(i = 0\)  to  \(N-2\) .</p> 
    $$ 
    \text{If } d_i \geq 2^{b_i-1}:
    (d_i, d_{i+1}) \leftarrow (d_i - 2^{b_i}, d_{i+1} + 1)
    $$
    <p>After performing this transform, digits  \(d_i\in[-2^{b_i-1}, 2^{b_i-1}-1]\)  for  \(i\in[0,N-2]\) .</p><p>The downstream point adder can exploit this new digit base because point negation is extremely cheap (on the Twisted Edwards affine space, it just corresponds to negative the x-coordinate). So, for all but the final window, we can halve the number of buckets and use point subtraction for all the negative buckets.</p><p>The module implements this transform as a fully unrolled (N-1)-stage pipeline, with optional skid buffers in order to cut combinational ready signal paths. It is designed in a modular way so that the overall scalar transformation can be extended to include many further transforms using other scalars (i.e. 2, 3, etc.), if point multiples were precomputed and loaded in the FPGA.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Axi512" class="anchored"><a href="#module-Axi512" class="anchor"></a><code><span><span class="keyword">module</span> Axi512</span><span> = <a href="../../Hardcaml_axi/Axi512/index.html">Hardcaml_axi.Axi512</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Config/index.html">Config</a> : <a href="../Config_intf/module-type-S/index.html">Config.S</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>